<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Kexin Tang">
    
    <title>
        
            DDIA cookbook - (11)Stream Processing |
        
        Kexin&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/otter-solid.svg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"kexintang.xyz","root":"/","language":"en","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#ff9f43","logo":null,"favicon":"/images/otter-solid.svg","avatar":"/images/OtterAvatar.jpg","font_size":null,"font_family":null,"hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"闲云野鹤||A lone cloud","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":true}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":false,"custom_label_list":[]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
               Kexin&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               target="_blank" rel="noopener" href="https://drive.google.com/file/d/13-0bw5teEW1AYoNnH5pRfsbnT48hkBJr/view?usp=drive_link"
                            >
                                RESUME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       target="_blank" rel="noopener" href="https://drive.google.com/file/d/13-0bw5teEW1AYoNnH5pRfsbnT48hkBJr/view?usp=drive_link">RESUME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">DDIA cookbook - (11)Stream Processing</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/OtterAvatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Kexin Tang</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-12-15 10:25:53</span>
        <span class="mobile">2023-12-15 10:25</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2024-01-08 12:27:48</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/System-Design/">System Design</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/DDIA/">DDIA</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>For batch processing, the key is that the data is <strong>bounded</strong>, i.e. of a known and finite size so the batch process knows when it has finished reading inputs. In reality, a lot of data is unbounded because it arrives gradually over time, you have no idea about when to stop reading. Thus, batch processors must artificially divide the data into chunks of fixed duration. For stream processor, the data is incrementally made available over time.</p>
<hr>
<h1 id="Transmitting-Event-Streams"><a href="#Transmitting-Event-Streams" class="headerlink" title="Transmitting Event Streams"></a>Transmitting Event Streams</h1><p>In batch processing, the inputs and outputs are files (chunks of data). In stream processing, the inputs are <em><strong>events</strong></em>.</p>
<blockquote>
<p>Actually event is just a small, self-contained, immutable object containing the details of something that happended at some point in time. An event usually contains a timestamp indicating when it happened according to a time-of-day clock.</p>
</blockquote>
<p>In batch processing, a file is written once and then potentially read by multiple jobs. And a filename indentifies a set of related records. </p>
<p>In streaming terminology, an event is generated once by a <em><strong>producer</strong></em> (also known as a publisher or sender), and then potentially processed by multiple <em><strong>consumers</strong></em> (subscribers or recipients). And related events are grouped together into a <em><strong>topic</strong></em>.</p>
<h2 id="Messaging-Systems"><a href="#Messaging-Systems" class="headerlink" title="Messaging Systems"></a>Messaging Systems</h2><p>The most significant change for stream processing system is: the consumers only consume topics or events when they are <strong>notified</strong>.</p>
<p>A common approach for notifying consumers about new events is to use a messaging system: a producer sends a message containing the event, which is then pushed to consumers, via communication channels like TCP. But the problem is: TCP is one-to-one, while stream processing needs one-to-many or many-to-many. We call it <strong>publish&#x2F;subscribe model</strong>.</p>
<h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><ol>
<li>What happens if the producers send messages faster than the consumers can process them?<ol>
<li>drop messages</li>
<li>buffer messages in a queue &rarr; does the system crash if the queue no longer fits in memory, or does it write messages to disk?</li>
<li>backpressure (flow control)</li>
</ol>
</li>
<li>What happens if nodes crash or temporarily go offline—are any messages lost?</li>
</ol>
<p>A nice property of the batch processing systems is that <strong>batch processing systems provide a strong reliability guarantee</strong>: failed tasks are automatically retried, and partial output from failed tasks is automatically discarded. This means the output is the same as if no failures had occurred, which helps simplify the programming model.</p>
<h3 id="Direct-messaging-from-producers-to-consumers"><a href="#Direct-messaging-from-producers-to-consumers" class="headerlink" title="Direct messaging from producers to consumers"></a>Direct messaging from producers to consumers</h3><p>A number of messaging systems use direct network communication between producers and consumers without going via intermediary nodes. It’s pretty simple and straight forward.</p>
<p>However, these methods generally require the application code to be aware of the possibility of message loss. And the faults they can tolerate are quite limited: even if the protocols detect and retransmit packets that are lost in the network, they generally assume that producers and consumers are constantly online.</p>
<h3 id="Message-brokers-Message-queue"><a href="#Message-brokers-Message-queue" class="headerlink" title="Message brokers &#x2F; Message queue"></a>Message brokers &#x2F; Message queue</h3><p>It runs as a server, with producers and consumers connecting to it as clients. Producers write messages to the broker, and consumers receive them by reading them from the broker.</p>
<p>By centralizing the data in the broker, these systems can more easily tolerate clients that come and go (connect, disconnect, and crash), and the question of durability is moved to the broker instead (broker can be configured how to tolerate message loss, application codes can ignore message loss).</p>
<blockquote>
<p>Asynchronous &rarr; when a producer sends a message, it normally only waits for the broker to confirm that it has buffered the message and does not wait for the message to be processed by consumers. The delivery to consumers will happen at some undetermined future point in time.</p>
</blockquote>
<h4 id="Compared-to-databases"><a href="#Compared-to-databases" class="headerlink" title="Compared to databases"></a>Compared to databases</h4><ul>
<li>Databases usually keep data until it is explicitly deleted, whereas most message brokers automatically delete a message when it has been successfully delivered to its consumers.</li>
<li>Most message brokers assume that their working set is fairly small—i.e., the queues are short.</li>
<li>Databases often support secondary indexes and various ways of searching for data, while message brokers often support some way of subscribing to a subset of topics matching some pattern.</li>
<li>When querying a database, the result is typically based on a point-in-time snapshot of the data. By contrast, message brokers do not support arbitrary queries, but they do notify clients when data changes.</li>
</ul>
<h4 id="Multiple-consumers"><a href="#Multiple-consumers" class="headerlink" title="Multiple consumers"></a>Multiple consumers</h4><p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/n8KiyyQ.png"
                      alt="multiple consumers"
                ></p>
<ul>
<li>Load balancing &rarr; multiple consumers share the broker</li>
<li>Fan-out &rarr; each message is delivered to all of the consumers</li>
</ul>
<p>And these two patterns can be combined: for example, two separate groups of consumers may each subscribe to a topic, such that each group collectively receives all messages, but within each group only one of the nodes receives each message.</p>
<h4 id="Acknowledgments-and-redelivery"><a href="#Acknowledgments-and-redelivery" class="headerlink" title="Acknowledgments and redelivery"></a>Acknowledgments and redelivery</h4><p>Consumers may crash at any time, so it could happen that a broker delivers a message to a consumer but the consumer never processes it, or only partially processes it before crashing. In order to ensure that the message is not lost, message brokers use <em><strong>acknowledgments</strong></em>: a client must explicitly tell the broker when it has finished processing a message so that the broker can remove it from the queue.</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/FnKO6AL.png"
                      alt="reorder"
                ></p>
<p><strong>Reordering</strong> is a problem when consider load balancing + redelivery. For example, if m3 crashed in consumer2, then we redeliver m3 to consumer1. The final order becomes [m2, m4, m3, m5] rather than [m2, m3, m4, m5].</p>
<h2 id="Log-based-Messaging"><a href="#Log-based-Messaging" class="headerlink" title="Log-based Messaging"></a>Log-based Messaging</h2><h3 id="Difference-between-database-with-traditional-broker"><a href="#Difference-between-database-with-traditional-broker" class="headerlink" title="Difference between database with traditional broker"></a>Difference between database with traditional broker</h3><p>Everything that is written to a database is normally expected to be recorded in logs first (WAL). However, for message brokers that durably write messages to disk will quickly delete them again after they have been delivered to consumers, because they are built around a transient messaging mindset.</p>
<blockquote>
<p>If a new consumer is added to a messaging system, it can only read messages that sent after the time it was registered, while in database system, it can retrive historical records.</p>
</blockquote>
<p>This difference has a big impact on how derived data is created. A key feature of batch processes, is that you can run them repeatedly. This is not the case with messaging: receiving a message is destructive if the acknowledgment causes it to be deleted from the broker, so you cannot run the same consumer again and expect to get the same result.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>log-based message broker</strong> is a hybrid, combining the durable storage approach of databases with the low-latency notification facilities of messaging. Because it has durable log (historical data), we can also do some operations like batch processing, for example, get all messages from yesterday.</p>
<blockquote>
<p>A log is simply an append-only sequence of records on disk.</p>
</blockquote>
<p>A producer sends a message by appending it to the end of the log, and a consumer receives messages by reading the log sequentially. If a consumer reaches the end of the log, it waits for a notification that a new message has been appended.</p>
<p>For scalability, logs can be partioned. A topic can then be defined as a group of partitions that all carry messages of the same type.</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/aj8lrKS.png"
                      alt="partitioned broker"
                ></p>
<p>Within each partition, the broker assigns a monotonically increasing sequence number, or offset, to every message. Such a sequence number makes sense because a partition is append-only, so the messages within a partition are totally ordered. There is no ordering guarantee across different partitions.</p>
<p>Since partitioned logs typically preserve message ordering only within a single partition, all messages that need to be ordered consistently need to be routed to the same partition.</p>
<h3 id="Consumer-offsets"><a href="#Consumer-offsets" class="headerlink" title="Consumer offsets"></a>Consumer offsets</h3><p>Consuming a partition sequentially makes it easy to tell which messages have been processed: all messages with an offset less than a consumer’s current offset have already been processed, and all messages with a greater offset have not yet been seen. Thus, the broker doesn’t need to wait for all acknowledgements.</p>
<blockquote>
<p>For example, if broker stores message #1 to #10, and it receives ack for #8, which means #1-#8 already been consumed, it can delete message #1 to #8, and wait for ack number that greater than 8.</p>
</blockquote>
<p>If a consumer fails, another idle node can be assigned to consume this partition, and starts at the last recorded offset. When the failed consumer recovers, it continues to consume according to the offset.</p>
<blockquote>
<p>This is similar to <em>log sequence number</em> in single-leader replication. It allows a follower to reconnect to a leader after it has become disconnected, and resume replication without skipping any writes.</p>
</blockquote>
<h3 id="When-consumers-cannot-keep-up-with-producers"><a href="#When-consumers-cannot-keep-up-with-producers" class="headerlink" title="When consumers cannot keep up with producers"></a>When consumers cannot keep up with producers</h3><p>The log is actually divided into segments, and from time to time old segments are deleted or moved to archive storage (common implementation includes <em><strong>ring buffer</strong></em>). If a <strong>slow consumer</strong> cannot keep up with the rate of messages, and it falls so far behind that its consumer offset points to a deleted segment, it will miss some of the messages.</p>
<p>You can monitor how far a consumer is behind, and raise an alert to ask some human operations.</p>
<p>The good news is: the slow consumer only affects its own partition, it doesn’t disrupt other consumers. When a consumer is shut down or crashes, it stops consuming resources—the only thing that remains is its consumer offset.</p>
<hr>
<h1 id="Databases-and-Streams"><a href="#Databases-and-Streams" class="headerlink" title="Databases and Streams"></a>Databases and Streams</h1><p>Log-based message broker uses some database logics in stream system. On the other hand, database can also use some logics of steam system.</p>
<h2 id="Keeping-Systems-in-Sync"><a href="#Keeping-Systems-in-Sync" class="headerlink" title="Keeping Systems in Sync"></a>Keeping Systems in Sync</h2><p>If periodic full database dumps are too slow (for example, dump whole data to build index and cache), an alternative that is sometimes used is <strong>dual writes</strong>, in which the application code explicitly writes to each of the systems when data changes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.run_sql(<span class="string">&quot;SQL COMMAND&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> check_state(db):  <span class="comment"># only run multiple operations when data changes</span></span><br><span class="line">    update_cache(db)</span><br><span class="line">    build_index(db)</span><br></pre></td></tr></table></figure>

<h3 id="Problems-Dual-Writes"><a href="#Problems-Dual-Writes" class="headerlink" title="Problems @ Dual Writes"></a>Problems @ Dual Writes</h3><ul>
<li>Concurrency &rarr; in the database, X is first set to A and then to B, while at the search index the writes arrive in the opposite order.</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/faXkIgR.png"
                      alt="Dual Writes"
                ></p>
<ul>
<li>Fault-tolerance &rarr; in the database, building index succeeds, but buding cache fails.</li>
</ul>
<h2 id="Change-Data-Capture"><a href="#Change-Data-Capture" class="headerlink" title="Change Data Capture"></a>Change Data Capture</h2><p>The problem with most databases’ replication logs is that they have long been considered to be an internal implementation detail of the database, not a public API. Clients are supposed to query the database through its data model and query language, not parse the replication logs and try to extract data from them.</p>
<p><strong>Change data capture (CDC)</strong>, which is <strong>the process of observing all data changes written to a database and extracting them in a form in which they can be replicated to other systems</strong>. CDC is especially interesting if changes are made available as a stream, immediately as they are written.</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://i.imgur.com/Ga5sEEU.png"
                      alt="CDC"
                ></p>
<p>“Writing data in database” is the event, and “log in disk” is the message. The search index and any other derived data systems are just consumers of the change stream (log change as message broker).</p>
<p>Change data capture is a mechanism for ensuring that all changes made to the system of record are also reflected in the derived data systems so that the derived systems have an accurate copy of the data.</p>
<blockquote>
<p>System of record is the groud truth, derived data system is another representation of the groud truth. CDC means: if the groud truth has change, then map this change to other representations.</p>
</blockquote>
<h3 id="Implementing-CDC"><a href="#Implementing-CDC" class="headerlink" title="Implementing CDC"></a>Implementing CDC</h3><p>ssentially, change data capture makes one database the leader (the one from which the changes are captured), and turns the others into followers. A log-based message broker is well suited for transporting the change events from the source database to the derived systems, since it preserves the ordering of messages.</p>
<blockquote>
<p>CDC sounds like TRIGGER in DB, but TRIGGER is hard to use and has significant performance overheads, because TRIGGER will focus on data itself. While CDC mainly analyzes logs rather than data.</p>
</blockquote>
<h3 id="Snapshot-and-Log-compaction"><a href="#Snapshot-and-Log-compaction" class="headerlink" title="Snapshot and Log compaction"></a>Snapshot and Log compaction</h3><p>For database replication, it has <em>log sequence number</em> to record the snapshot, if the database is crushed, then it will recover from the snapshot rather than from the very begining. It’s the same for CDC, it will only copy the changes after the snapshot to derived systems.</p>
<blockquote>
<p>For example, if the system of record system has the following records:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">99  set A = 0</span><br><span class="line">100 set A = 1 &lt;- snapshot / LSN in database</span><br><span class="line">101 set A = 2</span><br><span class="line">102 set B = A</span><br><span class="line">103 set B = B + 1</span><br></pre></td></tr></table></figure>
<p>Then CDC can just use record number greater than 100 to build derived data.</p>
</blockquote>
<p>For key-value structured system, it can compact its log by using new value to overwrite old value for the same key. For CDC, the log can only keeps the newest values, and when build derived systems, they can just use these newest values.</p>
<blockquote>
<p>For example, if the system of record system has the following records:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">99  set A = 0</span><br><span class="line">100 set A = 1</span><br><span class="line">101 set A = 2</span><br><span class="line">102 set B = A</span><br><span class="line">103 set B = B + 1</span><br></pre></td></tr></table></figure>
<p>Then CDC can just keep compacted logs to build derived data.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set A = 2</span><br><span class="line">set B = 3</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h1 id="Processing-Streams"><a href="#Processing-Streams" class="headerlink" title="Processing Streams"></a>Processing Streams</h1><p>Streams can work as pipe: <strong>a stream processor consumes input streams in a read-only fashion and writes its output to a different location in an append-only fashion</strong>.</p>
<p>The partitioning, parallelization, mapping operations like transforming and filtering are the same as MapReduce (batch processing).</p>
<p>The one crucial difference to batch jobs is that <strong>a stream never ends</strong>:</p>
<ul>
<li>Sort doesn’t make sense &rarr; unbound dataset cannot be sorted</li>
<li>Fault tolerance mechanisms changes &rarr; batch processing can be restarted, but stream processing is endless</li>
</ul>
<h2 id="Uses-of-Stream-Processing"><a href="#Uses-of-Stream-Processing" class="headerlink" title="Uses of Stream Processing"></a>Uses of Stream Processing</h2><ul>
<li>Complex event processing (CEP) &rarr; It is an approach developed for analyzing event streams, especially geared toward the kind of application that requires searching for certain event patterns, for example, to find invalid operations in a long-term transaction.</li>
<li>Stream analytics &rarr; Usually be used to do aggregations and statistical metrics over a large number of events, for example, calculate statistics in a live TV show.</li>
<li>Maintaining materialized views &rarr; A stream of changes to a database can be used to keep derived data systems, such as caches, search indexes, and data warehouses, up to date with a source database. Use stream processing can maintain these materialized views for efficient calculations and queries.</li>
</ul>
<h2 id="Reasoning-About-Time"><a href="#Reasoning-About-Time" class="headerlink" title="Reasoning About Time"></a>Reasoning About Time</h2><p>For batch processing, timing is not a huge problem. Because batch processing only processes historical data, so the requirements are always like “the average between 01&#x2F;01&#x2F;2023 and 12&#x2F;31&#x2F;2023”. There is no point in looking at the system clock of the machine running the batch process, it only use the timestamp in the record &#x2F; dataset.</p>
<p>However, for stream processing, the requirements are like “the average over the last 30 seconds”, it touches the log timestamp and the system clock of running machine, where the lag and drift may occur.</p>
<h3 id="Event-time-Vs-Processing-time"><a href="#Event-time-Vs-Processing-time" class="headerlink" title="Event time Vs Processing time"></a>Event time Vs Processing time</h3><p>Processing may be delayed by queuing, network failing, etc, and can also lead to unpredictable ordering of messages.</p>
<p>Confusing event time and processing time leads to bad data. For example, say you have a stream processor that measures the rate of requests (counting the number of requests per second). If you redeploy the stream processor, it may be shut down for a minute and process the backlog of events when it comes back up. If you measure the rate based on the processing time, it will look as if there was a sudden anomalous spike of requests while processing the backlog, when in fact the real rate of requests was steady.</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/"
                      alt="Figure11-7"
                ></p>
<h3 id="Knowing-when-you’re-ready"><a href="#Knowing-when-you’re-ready" class="headerlink" title="Knowing when you’re ready"></a>Knowing when you’re ready</h3><p>A tricky problem when defining windows in terms of event time is that you can never be sure when you have received all of the events for a particular window, or whether there are some events still to come.</p>
<p>For example, say you’re grouping events into one-minute windows so that you can count the number of requests per minute. You can time out and declare a window ready after you have not seen any new events for that window in a while. However, it could still happen that some events were buffered on another machine somewhere, delayed due to a network interruption. You need to be able to handle such straggler events that arrive after the window has already been declared complete.</p>
<ol>
<li>Ignore the straggler events, as they are probably a small percentage of events in normal circumstances. You can track the number of dropped events as a metric, and alert if you start dropping a significant amount of data.</li>
<li>Publish a correction, an updated value for the window with stragglers included. You may also need to retract the previous output.</li>
</ol>
<h3 id="Whose-clock-are-you-using"><a href="#Whose-clock-are-you-using" class="headerlink" title="Whose clock are you using?"></a>Whose clock are you using?</h3><p>Imagine the event can be buffer in mobile phone, PC, server and other devices. Different devices have different clocks, which may cause drift or skew. Whose clock are correct?</p>
<p>To adjust for incorrect device clocks, one approach is to log three timestamps:</p>
<ol>
<li>The time at which the event occurred, according to the device clock</li>
<li>The time at which the event was sent to the server, according to the device clock</li>
<li>The time at which the event was received by the server, according to the server clock</li>
</ol>
<p>By subtracting the second timestamp from the third, you can estimate the offset between the device clock and the server clock. You can then apply that offset to the event timestamp, and thus estimate the true time at which the event actually occurred.</p>
<h3 id="Types-of-windows"><a href="#Types-of-windows" class="headerlink" title="Types of windows"></a>Types of windows</h3><p>Once you know how the timestamp of an event should be determined, the next step is to decide how windows over time periods should be defined. The window can then be used for aggregations, for example to count events, or to calculate the average of values within the window. Several types of windows are in common use:</p>
<ol>
<li>Tumbling window</li>
</ol>
<p>A tumbling window has a fixed length, and every event belongs to exactly one window. For example, if you have a 1-minute tumbling window, all the events with timestamps between 10:03:00 and 10:03:59 are grouped into one window, events between 10:04:00 and 10:04:59 into the next window, and so on. You could implement a 1-minute tumbling window by taking each event timestamp and rounding it down to the nearest minute to determine the window that it belongs to.</p>
<ol start="2">
<li>Hopping window</li>
</ol>
<p>A hopping window also has a fixed length, but allows windows to overlap in order to provide some smoothing. For example, a 5-minute window with a hop size of 1 minute would contain the events between 10:03:00 and 10:07:59, then the next window would cover events between 10:04:00 and 10:08:59, and so on. You can implement this hopping window by first calculating 1-minute tumbling windows, and then aggregating over several adjacent windows.</p>
<ol start="3">
<li>Sliding window</li>
</ol>
<p>A sliding window contains all the events that occur within some interval of each other. For example, a 5-minute sliding window would cover events at 10:03:39 and 10:08:12, because they are less than 5 minutes apart (note that tumbling and hopping 5-minute windows would not have put these two events in the same window, as they use fixed boundaries). A sliding window can be implemented by keeping a buffer of events sorted by time and removing old events when they expire from the window.</p>
<ol start="4">
<li>Session window</li>
</ol>
<p>Unlike the other window types, a session window has no fixed duration. Instead, it is defined by grouping together all events for the same user that occur closely together in time, and the window ends when the user has been inactive for some time (for example, if there have been no events for 30 minutes). Sessionization is a common requirement for website analytics.</p>
<h2 id="Stream-JOINs"><a href="#Stream-JOINs" class="headerlink" title="Stream JOINs"></a>Stream JOINs</h2><p>New events can appear anytime on a stream makes joins on streams more challenging than in batch jobs.</p>
<h3 id="Stream-stream-JOIN-window-JOIN"><a href="#Stream-stream-JOIN-window-JOIN" class="headerlink" title="Stream-stream JOIN (window JOIN)"></a>Stream-stream JOIN (window JOIN)</h3><p>For example, in a website, we have two streams:</p>
<ol>
<li>when user search a keyword, record an event that contains the keyword and its results.</li>
<li>when user click one URL, record an event.</li>
</ol>
<p>In order to calculate the click-through rate for each URL in the search results, you need to bring together the events for the search action and the click action, which are connected by having the same session ID.</p>
<blockquote>
<p>Why not just record the URL when we click? Why JOIN? Because the click may never come if the user abandons their search, and even if it comes, the time between the search and the click may be highly variable.</p>
<p>For example, the user searched 10 times, but only clicked 5 times. If we just record the URL when user clicks, we only have information like “the user searched and clicked 5 times”, while if we do recording then JOIN, we will have “the user searched 10 but clicked 5, 5 still missing”.</p>
<p>Note that record the details of the search in the click event is not equivalent to joining the events: doing so would only tell you about the cases where the user clicked a search result, not about the searches where the user did not click any of the results. In order to measure search quality, you need accurate click-through rates, for which you need both the search events and the click events.</p>
</blockquote>
<p>To implement this type of join, a stream processor needs to maintain <strong>state</strong>: for example, all the events that occurred in the last hour, indexed by session ID. Whenever a search event or click event occurs, it is added to the appropriate index, and the stream processor also checks the other index to see if another event for the same session ID has already arrived. If there is a matching event, you emit an event saying which search result was clicked. If the search event expires without you seeing a matching click event, you emit an event saying which search results were not clicked.</p>
<h3 id="Stream-table-JOIN-stream-enrichment"><a href="#Stream-table-JOIN-stream-enrichment" class="headerlink" title="Stream-table JOIN (stream enrichment)"></a>Stream-table JOIN (stream enrichment)</h3><p>For example, one user continously change his profile, e.g. modifying his username, password, address and payment method. It’s a stream. And all of his information is in a database table. This JOIN just use the stream events to modify table values.</p>
<h3 id="Table-table-JOIN-materialized-view-maintenance"><a href="#Table-table-JOIN-materialized-view-maintenance" class="headerlink" title="Table-table JOIN (materialized view maintenance)"></a>Table-table JOIN (materialized view maintenance)</h3><p>Just like JOIN in database, the goal is to get up-to-date materialized view after stream events modifying the database tables.</p>

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/System-Design/">#System Design</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/DDIA/">#DDIA</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/12/12/DDIA-cookbook-10-Batch-Processing/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">DDIA cookbook - (10)Batch Processing</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Intro"><span class="nav-number">1.</span> <span class="nav-text">Intro</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Transmitting-Event-Streams"><span class="nav-number">2.</span> <span class="nav-text">Transmitting Event Streams</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Messaging-Systems"><span class="nav-number">2.1.</span> <span class="nav-text">Messaging Systems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Problems"><span class="nav-number">2.1.1.</span> <span class="nav-text">Problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Direct-messaging-from-producers-to-consumers"><span class="nav-number">2.1.2.</span> <span class="nav-text">Direct messaging from producers to consumers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Message-brokers-Message-queue"><span class="nav-number">2.1.3.</span> <span class="nav-text">Message brokers &#x2F; Message queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Compared-to-databases"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">Compared to databases</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multiple-consumers"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">Multiple consumers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Acknowledgments-and-redelivery"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">Acknowledgments and redelivery</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Log-based-Messaging"><span class="nav-number">2.2.</span> <span class="nav-text">Log-based Messaging</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Difference-between-database-with-traditional-broker"><span class="nav-number">2.2.1.</span> <span class="nav-text">Difference between database with traditional broker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solution"><span class="nav-number">2.2.2.</span> <span class="nav-text">Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer-offsets"><span class="nav-number">2.2.3.</span> <span class="nav-text">Consumer offsets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#When-consumers-cannot-keep-up-with-producers"><span class="nav-number">2.2.4.</span> <span class="nav-text">When consumers cannot keep up with producers</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Databases-and-Streams"><span class="nav-number">3.</span> <span class="nav-text">Databases and Streams</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Keeping-Systems-in-Sync"><span class="nav-number">3.1.</span> <span class="nav-text">Keeping Systems in Sync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Problems-Dual-Writes"><span class="nav-number">3.1.1.</span> <span class="nav-text">Problems @ Dual Writes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Change-Data-Capture"><span class="nav-number">3.2.</span> <span class="nav-text">Change Data Capture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-CDC"><span class="nav-number">3.2.1.</span> <span class="nav-text">Implementing CDC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Snapshot-and-Log-compaction"><span class="nav-number">3.2.2.</span> <span class="nav-text">Snapshot and Log compaction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Processing-Streams"><span class="nav-number">4.</span> <span class="nav-text">Processing Streams</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Uses-of-Stream-Processing"><span class="nav-number">4.1.</span> <span class="nav-text">Uses of Stream Processing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reasoning-About-Time"><span class="nav-number">4.2.</span> <span class="nav-text">Reasoning About Time</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-time-Vs-Processing-time"><span class="nav-number">4.2.1.</span> <span class="nav-text">Event time Vs Processing time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Knowing-when-you%E2%80%99re-ready"><span class="nav-number">4.2.2.</span> <span class="nav-text">Knowing when you’re ready</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Whose-clock-are-you-using"><span class="nav-number">4.2.3.</span> <span class="nav-text">Whose clock are you using?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Types-of-windows"><span class="nav-number">4.2.4.</span> <span class="nav-text">Types of windows</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-JOINs"><span class="nav-number">4.3.</span> <span class="nav-text">Stream JOINs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-stream-JOIN-window-JOIN"><span class="nav-number">4.3.1.</span> <span class="nav-text">Stream-stream JOIN (window JOIN)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-table-JOIN-stream-enrichment"><span class="nav-number">4.3.2.</span> <span class="nav-text">Stream-table JOIN (stream enrichment)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Table-table-JOIN-materialized-view-maintenance"><span class="nav-number">4.3.3.</span> <span class="nav-text">Table-table JOIN (materialized view maintenance)</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2023</span> -
            
            2024
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">Kexin Tang</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-block.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/post-helper.js"></script>

        
            
<script src="/js/libs/anime.min.js"></script>

        
        
            
<script src="/js/toc.js"></script>

        
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>

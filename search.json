[{"title":"Why and why not inline","url":"/2023/07/20/Why-and-why-not-inline/","content":"Why inlineIn C++, we can add inline keyword in front of function defination (inline only works on defination, you don’t need to use inline in statement).\nvoid this_is_inline_func();inline void this_is_inline_func() &#123;    std::cout &lt;&lt; &quot;this is inline func&quot; &lt;&lt; std::endl;&#125;\n\nno inlineWhen we call a function, the process is\n\nfind function defination and its address\nload from memory to stack\nexecute\npop from stack\n\nvoid this_is_not_inline() &#123;    ...&#125;this_is_not_inline();   // 1this_is_not_inline();   // 2this_is_not_inline();   // 3\n\n0x0000 -&gt; defination of this_is_not_inline...0x0100 -&gt; call 1    // find address is 0x0000 -&gt; push 0x0000 into stack -&gt; execute -&gt; pop0x0104 -&gt; call 2    // same0x0108 -&gt; call 3    // same\n\ninlineAll of these steps will cost extra time. To avoid this cost, we can use inline. After we defining a function as inline, we may have multiple calls in code. When we compile the code, the compiler will change function calls to function defination, so that when execute the code, instead of wasting time finding defination and loading from memory to stack, it just executes the function logic.\nvoid this_is_inline() &#123;    std::cout &lt;&lt; &quot;this is inline func&quot; &lt;&lt; std::endl;&#125;this_is_inline();   // 1this_is_inline();   // 2this_is_inline();   // 3\n\n0x0000 -&gt; defination of this_is_inline...0x0100 -&gt; std::cout &lt;&lt; &quot;this is inline func&quot; &lt;&lt; std::endl;  // change call to defination0x0200 -&gt; std::cout &lt;&lt; &quot;this is inline func&quot; &lt;&lt; std::endl;0x0300 -&gt; std::cout &lt;&lt; &quot;this is inline func&quot; &lt;&lt; std::endl;\n\n\nWhy not inlineSounds great? But the problem is, we need to copy the defination after every calls. If the defination is very complicated, we will cost losts of memory. What’s more, if the function is complicated, the execution time &gt;&gt; load &amp; pop stack time, we can ignore the inline improvement.\n\nSuggestionOnly use inline for very simple function. Actually inline is just a recommendation rather than requirement. If the function contains loop, recursion, static, etc complex logic, the function will be treated as not-inline even if you add inline keyword.\nWhat’s more, in class, the methods defination will be treated as inline. So only define simple methods in class, for complex methods, leave statements inside class, then define them outside class.\nclass Object &#123;public:    Object() =default;    Object(const Object&amp; rhs) &#123; num = rhs.num; &#125;    int get_num() &#123; return num; &#125;   // define simple method inside class (auto inline)    void inline_function();    void complex_function();private:    int num;&#125;;// we can still define inline outside classinline void Object::inline_function() &#123;    ...&#125;// for complex method, plz define outside classvoid Object::complex_function() &#123;    ...&#125;\n\n\n#define vs inline#define replaces the pure text in pre-complie stage, inline replaces function call with function defination in complie stage.\n","tags":["c++"]},{"title":"How to setup blog?","url":"/2023/07/14/how_to_setup_blog/","content":"GithubJust create a new repo, and the repo’s name follows rule “username.github.io”.\n\nNode.js &amp; HexoInstallJust donwload Node.js from offical website (maybe you also need npm :)). For Mac user, the simplest way is run command:\nbrew install node\n\nFor Hexo, we just need to run\nnpm install hexo-cli -g\n\nAfter installation, use commands to validate:\nnode -vnpm -vhexo -v\n\nInitIf everything is OK, run following commands:\nmkdir blog &amp;&amp; cd bloghexo init   # init the folder as blog reponpm install # install necessary node_modules\n\nThen you will find a file named blog/_config.yml, add these info in last rows:\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repository: &lt;your github repo&gt;  branch: master\n\nDeployYou can add a new plug-in npm i hexo-deployer-git so that we can post blogs to git via hexo.\nhexo new post &quot;this is post name&quot;hexo g  # generatehexo s  # can view changes in localhosthexo d  # deploy to github\n\n\n:money:\nActually this step is optional, cause u can use “username.github.io” to browse your blog. However, if you want a fancy URI (and you are rich), you can follow the step.\n\nYou should buy a web URI, I got one from GoDaddy.\nAfter you got one, let’s say it’s “myfancyblog.com”, you should set the DNS so that when other people enter “myfancyblog.com” in browser, it can re-direct to “username.github.io”.\nOther people                  Your github repo&quot;myfancyblog.com&quot;   - DNS -&gt;  &quot;username.github.io&quot;\n\nIn DNS Management page, you should set two more DNS Records.\n\n\n\nType\nName\nData\n\n\n\nA\n@\nIP Address For username.github.io\n\n\nCNAME\nwww\nusername.github.io\n\n\nThe first one re-directs “myfancyblog.com” to “username.github.io”‘s IP, the second re-directs “www.myfancyblog.com“ to “username.github.io”.\nThen, you should go back to your blog repo, in blog/source create a new file CNAME, then put “myfancyblog.com” in this file. hexo g &amp;&amp; hexo d. You will see github.com will have a new CNAME file, and you can check “Setting -&gt; Pages”, it should have “myfancyblog.com” in “Custom domain” field.\n\nTipsIf you are curious about “why I changed some settings but the web page seems no change”, :(, well, remember to clear the browser cache.\n","tags":["blog","tools"]},{"title":"tmux cookbook","url":"/2023/07/17/tmux-cookbook/","content":"TmuxWhen we use command line tools (CLI), we will open a terminal, and input some commands. This process called “session”. But session is temporary, which means when we close the terminal, the session ends.\nHow can we keep the session even we close the page?\nUsing Tmux :)\nTmux will create a new terminal (you can think this is a sub-terminal), and we can run commands inside. When we close the terminal, it will not end the session, just return back to the main terminal, we can connect the sub-terminal again via tmux.\nWhen use tmux?This is a difficult question. For me, I will use tmux in 2 situations:\n\nI want to show off. You know what I mean, multiple panes in one screen, especially use one pane to run top command, it’s just like hack style.\nThe task will take a long running time. For instance, the machine learning stuff, you can run it in one session, then go back to working. After one million year, re-connect the session and see error information like “No Module Named xxx” (just don’t ask me why I know that)\n\ncookbook\n\n\nCommand\nFunctionality\n\n\n\ntmux new -s &lt;name&gt;\ncreate a named session\n\n\ntmux detach\nkeep the session and go back to main terminal\n\n\ntmux ls\nlist sessions\n\n\ntmux attach -t &lt;name&gt;\nre-connect to session\n\n\ntmux kill-session -t &lt;name&gt;\nend session\n\n\ntmux switch -t &lt;name&gt;\nswitch to session\n\n\ntmux split-window\nsplit up &amp; down\n\n\ntmux split-window -h\nsplit left &amp; right\n\n\ntmux select-pane -U&#x2F;D&#x2F;L&#x2F;R\nselect up&#x2F;down&#x2F;left&#x2F;right pane\n\n\ntmux swap-pane -U&#x2F;D\nchange pane’s size\n\n\nhot key\n\n\nhot key\nfunctionality\n\n\n\nctrl+d\nexit and kill session\n\n\nctrl+b d\ntmux detach\n\n\nctrl+b ?\nhelp\n\n\nctrl+b s\ncheck all sessions\n\n\nctrl+b $\nrename session\n\n\nctrl+b %\nsplit left &amp; right\n\n\nctrl+b “\nsplit up &amp; down\n\n\nctrl+b x\nkill session\n\n\nctrl+b &lt;arrow key&gt;\nselect pane\n\n\nctrl+b ctrl+&lt;arrow key&gt;\nresize pane\n\n\nctrl+b !\nmake panes into different sessions\n\n\nctrl+b :set &lt;command&gt;\nset properties, eg: :set mouse on to enable mouse control\n\n\n","tags":["tools","cookbook"]},{"title":"#include <> Vs #include \"\" ","url":"/2023/07/16/cpp_include_difference/","content":"#include &lt;header&gt;This will let preprocessor find header files in pre-designated directories.\n\nThese directories are normally system-related, such as “&#x2F;usr&#x2F;include”, “&#x2F;x86&#x2F;include”, etc.\n\nLet’s use Linux as example. If we ls /usr, you will see bin, include and lib, and if we ls /usr/include, output will contain lots of system defined header files, such as /usr/include/cpp/vector and /usr/include/cpp/iostream. This is how we include these commonly used packages.\n// find header file named &quot;iostream&quot; from &quot;/usr/include&quot;#include &lt;iostream&gt;\n\n\n#include &quot;header&quot;This will search programmer-defined header files and typically includes same directory as the file containing the directive.\nmy_project| - include|   | - my_header.h| - my_project.cpp\n// my_project.cpp#include &quot;my_header.h&quot;\n\nLet’s assume the project tree looks like that, and when we #include &quot;&quot;, it will search header files under /my_project directory.\nIf the processor cannot find header file in current project directory, it will search header files in system path (the same as #include &lt;&gt;).\n\n#include &quot;header.h&quot; – cannot find locally –&gt; #include &lt;header.h&gt;\n\n\nAdd include pathAs we discussed before, #include &lt;&gt; will search pre-designated directories. What if we want the processor to search other directories?\nWe can add include paths via \n\n-I\nsystem environment variable\nCMake\n\nAfter adding include paths, the searching order is\n\n#include &lt;&gt;\ndir list\nsystem dir\n\n\n#include &quot;&quot;\nlocal\ndir list\nsystem dir\n\n\n\n-IWe can use -I flag in command line to add search paths.\ng++ -c test.cpp -o testg++ -c test.cpp -o test -I /path/to/certain/include/\n\nSystem environment variableThe system environment has a property called CPLUS_INCLUDE_PATH, we can set this to add search paths.\nexport CPLUS_INCLUDE_PATH=&quot;path/to/certain/include&quot;\n\nCMakeFor CMake, we can use include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) .\n","tags":["c++"]}]